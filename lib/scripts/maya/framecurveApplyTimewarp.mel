/*
    
    framecurve MEL script by Sebastian van Hesteren, Koen Hofmeester and Julik Tarkhanov.
    Body and soul of the framecurve concept.
    
    Usage: in File put a framecurve text file with tuples of "at_frame source_frame".
    for ex.: 
    1 4.55556
    2 5.22322
    3 6.45454
    etc.
    in Object put object whose animation curves will be timewarped
    
    run with: framecurve.timewarpDialog()

*/

global proc framecurve.timewarpDialog() {
	
	if (`window -ex shTimeWarperWin`){
		deleteUI shTimeWarperWin;
	}
	window -title "Apply framecurve timewarp" -s 0 -wh 300 150 shTimeWarperWin;
	string $form = `formLayout`;
	string $textbutFile  = `textFieldButtonGrp -cw 1 50 -label "File: " -buttonLabel "Browse" -buttonCommand "framecurve.getFile" framecurveFileField`;
	string $textbutCam  = `textFieldButtonGrp -cw 1 50 -label "Object: " -buttonLabel "Get" -buttonCommand "string $sel[] = `ls -sl`; textFieldGrp -e -tx $sel[0] framecurveDestinationObjectField;" framecurveDestinationObjectField`;
	string $butWarp = `button -label "Apply" -command "framecurve.applyTimewarp"`;
	

	formLayout -edit
	    -attachForm $textbutFile "top" 2
		-attachForm $textbutFile "left" 2
		-attachForm $textbutFile "right" 10
		-attachForm $textbutCam "left" 2
		-attachForm $textbutCam "right" 10
		-attachForm $butWarp "right" 10
		-attachForm $butWarp "left" 10
		-attachForm $butWarp "bottom" 10
		
		-attachControl $textbutCam "top" 10 $textbutFile
		-attachControl $butWarp "top" 10 $textbutCam
	$form;


	showWindow shTimeWarperWin;
}

global proc framecurve.getFile() {
    string $fileList = "*.framecurve.txt";
    
	if (getApplicationVersionAsFloat() >= 2011) {
		textFieldButtonGrp -e -tx `fileDialog2 -ff $fileList -fm 1` framecurveFileField;
	} else {
	    string $loadfile = `fileDialog -t "Get Warp File" -dm $fileList -m 0`;
	    textFieldButtonGrp -e -tx $loadfile framecurveFileField;
	}
}

// Check if the string is not a comment and not empty
proc int framecurve.stringIgnored(string $str) {
    if (size($str) == 0) return 1;
    if (startsWith($str, "#")) return 1;
    return 0;
}

// Disable or enable image planes in the viewport. 0 disable, 1 enable
// http://www.vfxoverflow.com/questions/716/suspending-viewport-updates-when-creating-keyframes-via-mel
proc string[] framecurve.toggleImagePlanes(int $mode) {
    string $result[];
    string $imagePlanes[] = `ls -type "imagePlane"`;
    for ($ip in $imagePlanes) {
        if ($mode) {
            if (`attributeQuery -n $ip -ex "imageNameStash"`)   {
                string $path = `getAttr ($ip+".imageNameStash")`;
                setAttr -type "string" ($ip + ".imageName")  $path;
                deleteAttr ($ip + ".imageNameStash") $path;
            } else {
            //  warning("this image plane was never disabled");
            }
        } else {
            if (! `attributeQuery -n $ip -ex "imageNameStash"`) {
                addAttr -ln  "imageNameStash" -dt "string" $ip;
            }
            string $path = `getAttr ($ip+".imageName")`;
            setAttr -type "string" ($ip + ".imageName") "";
            setAttr -type "string" ($ip + ".imageNameStash") $path;
        }
        $result[`size $result`] = $ip;
    }
    return $result;
}

global proc string[] framecurve.enableImagePlanes() {
     return framecurve.toggleImagePlanes(1);
}
global proc string[] framecurve.disableImagePlanes() {
     return framecurve.toggleImagePlanes(0);
}

global proc framecurve.applyCurve(string $tCurve, string $toObject) {
	$warpConnections = `listConnections -t animCurve $toObject`;
	
	// Feed the output of the time curve to inputs of all anim curves attached to the object.
	// Anim curve's input is the time at which the anim curve is sampled.
	for ($each in $warpConnections) {
		print("Connecting timewarp curve to " + $each);
		print(`connectAttr -f ($tCurve + ".output") ($each + ".input")` + "\n");
	}
	
	// Special case - if this is a camera we can also timewarp the image plane itself! which is awesome
	// to do this, get to the shape first
	// then get to the image plane
	string $connectedShapes[];
	$connectedShapes = `listRelatives -shapes  $toObject`;
	for ($shape in $connectedShapes) {
		if("camera" == `nodeType $shape`) {
			// The camera might have animation on the FOV, so recursively apply
			// to it as well
			print("Applying timewarp curve to the camera shape of " + $shape);
			
			framecurve.applyCurve($tCurve, $shape);
			
			// Imageplanes do not really have curves - they are coupled to a frame
			// expression, so we will override that explicitly
			$imagePlanes = `listConnections -type "imagePlane" $shape`;
			for ($plane in $imagePlanes) {
				print("Applying timewarp curve to the camera shape of " + $shape);
				//
				
				// resultCurveTimeToUnitless will be inserted as adapter
				print("Retiming image plane " + $plane);
				print(`connectAttr -f ($tCurve + ".output") ($plane + ".frameExtension")` + "\n");
			} 
		}
	}
}

global proc framecurve.applyTimewarp() {
	string $warpConnections[];
	string $warpFilePath = `textFieldGrp -q -tx framecurveFileField`;
	string $warpObject = `textFieldGrp -q -tx framecurveDestinationObjectField`;
	
	// Create a Time node and animate it. This is the only node that has a AnimCurveTT as
	// it's animation curve and this is THE curve type we need to connect to other curve's input
	// socket. Since the Time node cannot feed anything since Maya 2011 (but can be created) what we have to do is reconnect
	// the output of the animation curve of the time node directly to the other curve's inputs!
	// Of course the gothic rectocenctric MEL process does not allow us to just create an AnimCurveTT node and fill it with keyframes, and then
	// attach (since all USEFUL data in Maya is opaque and not script-modifiable).
	string $timeNode = `createNode time -n ($warpObject + "_TimeWarp")`;
	
	$fId = `fopen $warpFilePath "r"`;
	string $line;
	int $frameNo = 0;
	string $toks[];
	
	// To make viewport updates faster when we iterate through frames it makes sense to
	// disable the image planes
	framecurve.disableImagePlanes();
	while(`feof $fId` == 0) {
		$line = `fgetline $fId`;
		// Skip comment lines
		if(!framecurve.stringIgnored($line)) {
			tokenize($line, $toks);
			int $frameNo = $toks[0];
			float $frameValue = $toks[1];
			currentTime $frameNo;
			setAttr ($timeNode + ".outTime") $frameValue;
			// Framecurve spec enforces LINEAR interpolation!
			setKeyframe  -inTangentType "linear" -outTangentType "linear" ($timeNode + ".outTime");
		}
	}
	fclose $fId;
	
	// And reenable them
	framecurve.enableImagePlanes();
	
	// Now we have a curve we can actually use
	string $driverCurves[] = `listConnections -t animCurve $timeNode`;
	string $frameCurve = $driverCurves[0];
	
	framecurve.applyCurve($frameCurve, $warpObject);
	
	delete $timeNode;
}


//framecurve.timewarpDialog();